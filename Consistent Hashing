# 一致性hash(Consistent Hashing)

### 应用场景
N台Redis服务器提供缓存服务，需要对服务器进行负载均衡，将获取缓存的请求平均分发到每台服务器上

### 分布式缓存
当web服务器为了提高客户端的查询速度，会对数据进行缓存。并且随着数据规模的增加，一台缓存服务器无法满足，在增加服务器之后就存在怎么均衡的进行数据缓存。使用分布式缓存已经非常常见，但是分布式缓存存在的问题如何解决是重点

### 分布式缓存问题
- 随机策略：当缓存服务器不知不止一台的时候，最简单选择符缓存服务器的策略是随机方式，对于请求的key随机发送到一台缓存服务器，但这种策略面临存在两个问题，1，随机会发生相同的数据在多个服务器存有缓存，造成数据的荣誉冗余，2，已经存在缓存的数据，由于随机会发生没有命中缓存服务器的情况，因为无法保证每次相同的请求key会发送到相同的缓存服务器上。该策略在时间和空间效率上都不好
- 计算hash:为了解决随机策略的问题，可以使用计算hash的算法，保证对相同的key的请求会被发送到相同的服务器，比如```c h= Hash(key)%N```,其中Hash(key)可以是一个从字符串到unsigned int数据的转换函数，N是缓存服务器的数目,这样相同的key映射后就能获得到相同的服务器服务器
- 一致性hash：计算hash还是存在容错性和扩展性问题，比如假设现在有一台缓存服务器宕机，那么为了填补空缺，hash的计算就需要改成```c h=Hash(key)%(N-1)```重新计算，此时会造成大量的key被定位到不同的缓存服务器从而造成大量的缓存无法命中，新增服务器节点同样存在这个问题，一致性hash算法很好的解决了这个问题

### 一致性hash算法
- 算法简介：将整个hash至值空间组织成一个虚拟的圆环，hash函数H的值空间一般为0～2^32 -1,将各个服务器使用H进行hash，可以选择服务器的ip或主机名作为关键字进行hash，这样每个缓存服务器就确定其在这个圆环上的位置；下一步，是对请求的key同样使用H进行hash,将数据映射到这个圆环上，然后从该位置按顺时针方向行走，遇到的第一个服务器的位置就是应该定位到的缓存服务器。
- 虚拟节点：存在使用H对服务器进行hash是时，发生映射不均的情况，比如上面提到的圆环，如果有3台服务器计算了hash之后映射在一小段空间，这就会造成数据的缓存发生不平均的情况(数据倾斜问题)，增加虚拟节点是consistent hashing使用的策略，即对每一个服务器节点计算多个hash，每个计算结果位置都放置此服务器节点，成为虚拟节点

### Consistent Hashing Algo
```java
//to do 
```

参考链接：https://my.oschina.net/xianggao/blog/394545
